<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CHIP-SPV: Table of Contents</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CHIP-SPV<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Multiple backend interface for HIP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Table of Contents </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#function-type-qualifiers">Function-Type Qualifiers</a><ul>
<li><a href="#__device__"><code>__device__</code></a></li>
<li><a href="#__global__"><code>__global__</code></a></li>
<li><a href="#__host__"><code>__host__</code></a></li>
</ul>
</li>
<li><a href="#calling-__global__-functions">Calling <code>__global__</code> Functions</a></li>
<li><a href="#kernel-launch-example">Kernel-Launch Example</a></li>
<li><a href="#variable-type-qualifiers">Variable-Type Qualifiers</a><ul>
<li><a href="#__constant__"><code>__constant__</code></a></li>
<li><a href="#__shared__"><code>__shared__</code></a></li>
<li><a href="#__managed__"><code>__managed__</code></a></li>
<li><a href="#__restrict__"><code>__restrict__</code></a></li>
</ul>
</li>
<li><a href="#built-in-variables">Built-In Variables</a><ul>
<li><a href="#coordinate-built-ins">Coordinate Built-Ins</a></li>
<li><a href="#warpsize">warpSize</a></li>
</ul>
</li>
<li><a href="#vector-types">Vector Types</a><ul>
<li><a href="#short-vector-types">Short Vector Types</a></li>
<li><a href="#dim3">dim3</a></li>
</ul>
</li>
<li><a href="#memory-fence-instructions">Memory-Fence Instructions</a></li>
<li><a href="#synchronization-functions">Synchronization Functions</a></li>
<li><a href="#math-functions">Math Functions</a><ul>
<li><a href="#single-precision-mathematical-functions">Single Precision Mathematical Functions</a></li>
<li><a href="#double-precision-mathematical-functions">Double Precision Mathematical Functions</a></li>
<li><a href="#integer-intrinsics">Integer Intrinsics</a></li>
<li><a href="#floating-point-intrinsics">Floating-point Intrinsics</a></li>
</ul>
</li>
<li><a href="#texture-functions">Texture Functions</a></li>
<li><a href="#surface-functions">Surface Functions</a></li>
<li><a href="#timer-functions">Timer Functions</a></li>
<li><a href="#atomic-functions">Atomic Functions</a><ul>
<li><a href="#caveats-and-features-under-development">Caveats and Features Under-Development:</a></li>
</ul>
</li>
<li><a href="#warp-cross-lane-functions">Warp Cross-Lane Functions</a><ul>
<li><a href="#warp-vote-and-ballot-functions">Warp Vote and Ballot Functions</a></li>
<li><a href="#warp-shuffle-functions">Warp Shuffle Functions</a></li>
</ul>
</li>
<li><a href="#cooperative-groups-functions">Cooperative Groups Functions</a></li>
<li><a href="#warp-matrix-functions">Warp Matrix Functions</a></li>
<li><a href="#independent-thread-scheduling">Independent Thread Scheduling</a></li>
<li><a href="#profiler-counter-function">Profiler Counter Function</a></li>
<li><a href="#assert">Assert</a></li>
<li><a href="#printf">Printf</a></li>
<li><a href="#device-side-dynamic-global-memory-allocation">Device-Side Dynamic Global Memory Allocation</a></li>
<li><a href="#__launch_bounds__"><code>__launch_bounds__</code></a><ul>
<li><a href="#compiler-impact">Compiler Impact</a></li>
<li><a href="#cu-and-eu-definitions">CU and EU Definitions</a></li>
<li><a href="#porting-from-cuda-__launch_bounds">Porting from CUDA __launch_bounds</a></li>
<li><a href="#maxregcount">maxregcount</a></li>
</ul>
</li>
<li><a href="#register-keyword">Register Keyword</a></li>
<li><a href="#pragma-unroll">Pragma Unroll</a></li>
<li><a href="#in-line-assembly">In-Line Assembly</a></li>
<li><a href="#c-support">C++ Support</a></li>
<li><a href="#kernel-compilation">Kernel Compilation</a></li>
<li><a href="#gfx-arch-specific-kernel">GFX Arch specific kernel</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md638"></a>
Introduction</h1>
<p >HIP provides a C++ syntax that is suitable for compiling most code that commonly appears in compute kernels, including classes, namespaces, operator overloading, templates and more. Additionally, it defines other language features designed specifically to target accelerators, such as the following:</p><ul>
<li><a class="el" href="class_a.html">A</a> kernel-launch syntax that uses standard C++, resembles a function call and is portable to all HIP targets</li>
<li>Short-vector headers that can serve on a host or a device</li>
<li>Math functions resembling those in the "math.h" header included with standard C++ compilers</li>
<li>Built-in functions for accessing specific GPU hardware capabilities</li>
</ul>
<p >This section describes the built-in variables and functions accessible from the HIP kernel. It’s intended for readers who are familiar with Cuda kernel syntax and want to understand how HIP is different.</p>
<p >Features are marked with one of the following keywords:</p><ul>
<li><b>Supported</b>&mdash;HIP supports the feature with a Cuda-equivalent function</li>
<li><b>Not supported</b>&mdash;HIP does not support the feature</li>
<li><b>Under development</b>&mdash;the feature is under development but not yet available</li>
</ul>
<h1><a class="anchor" id="autotoc_md639"></a>
Function-Type Qualifiers</h1>
<h2><a class="anchor" id="autotoc_md640"></a>
&lt;tt&gt;__device__&lt;/tt&gt;</h2>
<p >Supported <code>__device__</code> functions are</p><ul>
<li>Executed on the device</li>
<li>Called from the device only</li>
</ul>
<p >The <code>__device__</code> keyword can combine with the host keyword (see <a href="#host"><b>host</b></a>).</p>
<h2><a class="anchor" id="autotoc_md641"></a>
&lt;tt&gt;__global__&lt;/tt&gt;</h2>
<p >Supported <code>__global__</code> functions are</p><ul>
<li>Executed on the device</li>
<li>Called ("launched") from the host</li>
</ul>
<p >HIP <code>__global__</code> functions must have a <code>void</code> return type, and the first parameter to a HIP <code>__global__</code> function must have the type <code>hipLaunchParm</code>. See <a href="#kernel-launch-example">Kernel-Launch Example</a>.</p>
<p >HIP lacks dynamic-parallelism support, so <code>__global__</code> functions cannot be called from the device.</p>
<h2><a class="anchor" id="autotoc_md642"></a>
&lt;tt&gt;__host__&lt;/tt&gt;</h2>
<p >Supported <code>__host__</code> functions are</p><ul>
<li>Executed on the host</li>
<li>Called from the host</li>
</ul>
<p ><code>__host__</code> can combine with <code>__device__</code>, in which case the function compiles for both the host and device. These functions cannot use the HIP grid coordinate functions (for example, "threadIdx.x"). <a class="el" href="class_a.html">A</a> possible workaround is to pass the necessary coordinate info as an argument to the function.</p>
<p ><code>__host__</code> cannot combine with <code>__global__</code>.</p>
<p >HIP parses the <code>__noinline__</code> and <code>__forceinline__</code> keywords and converts them to the appropriate Clang attributes.</p>
<h1><a class="anchor" id="autotoc_md643"></a>
Calling &lt;tt&gt;__global__&lt;/tt&gt; Functions</h1>
<p ><code>__global__</code> functions are often referred to as <em>kernels,</em> and calling one is termed <em>launching the kernel.</em> These functions require the caller to specify an "execution configuration" that includes the grid and block dimensions. The execution configuration can also include other information for the launch, such as the amount of additional shared memory to allocate and the stream where the kernel should execute. HIP introduces a standard C++ calling convention to pass the execution configuration to the kernel in addition to the Cuda &lt;&lt;&lt; &gt;&gt;&gt; syntax. In HIP,</p><ul>
<li>Kernels launch with either &lt;&lt;&lt; &gt;&gt;&gt; syntax or the "hipLaunchKernel" function</li>
<li>The first five parameters to hipLaunchKernel are the following:<ul>
<li><b>symbol kernelName</b>: the name of the kernel to launch. To support template kernels which contains "," use the HIP_KERNEL_NAME macro. The hipify tools insert this automatically.</li>
<li><b>dim3 gridDim</b>: 3D-grid dimensions specifying the number of blocks to launch.</li>
<li><b>dim3 blockDim</b>: 3D-block dimensions specifying the number of threads in each block.</li>
<li><b>size_t dynamicShared</b>: amount of additional shared memory to allocate when launching the kernel (see <a href="#__shared__"><b>shared</b></a>)</li>
<li><b>hipStream_t</b>: stream where the kernel should execute. <a class="el" href="class_a.html">A</a> value of 0 corresponds to the NULL stream (see <a href="#synchronization-functions">Synchronization Functions</a>).</li>
</ul>
</li>
<li>Kernel arguments follow these first five parameters</li>
</ul>
<div class="fragment"><div class="line">// Example pseudo code introducing hipLaunchKernel:</div>
<div class="line">__global__ MyKernel(hipLaunchParm lp, float *A, float *B, float *C, size_t N)</div>
<div class="line">{</div>
<div class="line">...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">MyKernel&lt;&lt;&lt;dim3(gridDim), dim3(groupDim), 0, 0&gt;&gt;&gt; (a,b,c,n);</div>
<div class="line">// Alternatively, kernel can be launched by</div>
<div class="line">// hipLaunchKernel(MyKernel, dim3(gridDim), dim3(groupDim), 0/*dynamicShared*/, 0/*stream), a, b, c, n);</div>
</div><!-- fragment --><p >The hipLaunchKernel macro always starts with the five parameters specified above, followed by the kernel arguments. HIPIFY tools optionally convert Cuda launch syntax to hipLaunchKernel, including conversion of optional arguments in &lt;&lt;&lt; &gt;&gt;&gt; to the five required hipLaunchKernel parameters. The dim3 constructor accepts zero to three arguments and will by default initialize unspecified dimensions to 1. See <a href="#dim3">dim3</a>. The kernel uses the coordinate built-ins (thread*, block*, grid*) to determine coordinate index and coordinate bounds of the work item that’s currently executing. See <a href="#coordinate-builtins">Coordinate Built-Ins</a>.</p>
<h1><a class="anchor" id="autotoc_md644"></a>
Kernel-Launch Example</h1>
<div class="fragment"><div class="line">// Example showing device function, __device__ __host__</div>
<div class="line">// &lt;- compile for both device and host</div>
<div class="line">float PlusOne(float x)</div>
<div class="line">{</div>
<div class="line">    return x + 1.0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__global__</div>
<div class="line">void</div>
<div class="line">MyKernel (hipLaunchParm lp, /*lp parm for execution configuration */</div>
<div class="line">          const float *a, const float *b, float *c, unsigned N)</div>
<div class="line">{</div>
<div class="line">    unsigned gid = threadIdx.x; // &lt;- coordinate index function</div>
<div class="line">    if (gid &lt; N) {</div>
<div class="line">        c[gid] = a[gid] + PlusOne(b[gid]);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line">void callMyKernel()</div>
<div class="line">{</div>
<div class="line">    float *a, *b, *c; // initialization not shown...</div>
<div class="line">    unsigned N = 1000000;</div>
<div class="line">    const unsigned blockSize = 256;</div>
<div class="line"> </div>
<div class="line">    MyKernel&lt;&lt;&lt;dim3(gridDim), dim3(groupDim), 0, 0&gt;&gt;&gt; (a,b,c,n);</div>
<div class="line">    // Alternatively, kernel can be launched by</div>
<div class="line">    // hipLaunchKernel(MyKernel, dim3(N/blockSize), dim3(blockSize), 0, 0,  a,b,c,N);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md645"></a>
Variable-Type Qualifiers</h1>
<h2><a class="anchor" id="autotoc_md646"></a>
&lt;tt&gt;__constant__&lt;/tt&gt;</h2>
<p >The <code>__constant__</code> keyword is supported. The host writes constant memory before launching the kernel; from the GPU, this memory is read-only during kernel execution. The functions for accessing constant memory (hipGetSymbolAddress(), hipGetSymbolSize(), hipMemcpyToSymbol(), hipMemcpyToSymbolAsync(), hipMemcpyFromSymbol(), hipMemcpyFromSymbolAsync()) are available.</p>
<h2><a class="anchor" id="autotoc_md647"></a>
&lt;tt&gt;__shared__&lt;/tt&gt;</h2>
<p >The <code>__shared__</code> keyword is supported.</p>
<p ><code>extern __shared__</code> allows the host to dynamically allocate shared memory and is specified as a launch parameter. Previously, it was essential to declare dynamic shared memory using the HIP_DYNAMIC_SHARED macro for accuracy, as using static shared memory in the same kernel could result in overlapping memory ranges and data-races.</p>
<p >Now, the HIP-Clang compiler provides support for extern shared declarations, and the HIP_DYNAMIC_SHARED option is no longer required..</p>
<h2><a class="anchor" id="autotoc_md648"></a>
&lt;tt&gt;__managed__&lt;/tt&gt;</h2>
<p >Managed memory, except the <code>__managed__</code> keyword, are supported in HIP combined host/device compilation. Support of <code>__managed__</code> keyword is under development.</p>
<h2><a class="anchor" id="autotoc_md649"></a>
&lt;tt&gt;__restrict__&lt;/tt&gt;</h2>
<p >The <code>__restrict__</code> keyword tells the compiler that the associated memory pointer will not alias with any other pointer in the kernel or function. This feature can help the compiler generate better code. In most cases, all pointer arguments must use this keyword to realize the benefit.</p>
<h1><a class="anchor" id="autotoc_md650"></a>
Built-In Variables</h1>
<h2><a class="anchor" id="autotoc_md651"></a>
Coordinate Built-Ins</h2>
<p >These built-ins determine the coordinate of the active work item in the execution grid. They are defined in <a class="el" href="hip__runtime_8h_source.html">hip_runtime.h</a> (rather than being implicitly defined by the compiler).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>HIP Syntax</b>   </th><th class="markdownTableHeadNone"><b>Cuda Syntax</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">threadIdx.x   </td><td class="markdownTableBodyNone">threadIdx.x    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">threadIdx.y   </td><td class="markdownTableBodyNone">threadIdx.y    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">threadIdx.z   </td><td class="markdownTableBodyNone">threadIdx.z    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">blockIdx.x   </td><td class="markdownTableBodyNone">blockIdx.x    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blockIdx.y   </td><td class="markdownTableBodyNone">blockIdx.y    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">blockIdx.z   </td><td class="markdownTableBodyNone">blockIdx.z    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">blockDim.x   </td><td class="markdownTableBodyNone">blockDim.x    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blockDim.y   </td><td class="markdownTableBodyNone">blockDim.y    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">blockDim.z   </td><td class="markdownTableBodyNone">blockDim.z    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gridDim.x   </td><td class="markdownTableBodyNone">gridDim.x    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">gridDim.y   </td><td class="markdownTableBodyNone">gridDim.y    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gridDim.z   </td><td class="markdownTableBodyNone">gridDim.z   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md652"></a>
warpSize</h2>
<p >The warpSize variable is of type int and contains the warp size (in threads) for the target device. Note that all current Nvidia devices return 32 for this variable, and all current AMD devices return 64. Device code should use the warpSize built-in to develop portable wave-aware code.</p>
<h1><a class="anchor" id="autotoc_md653"></a>
Vector Types</h1>
<p >Note that these types are defined in <a class="el" href="hip__runtime_8h_source.html">hip_runtime.h</a> and are not automatically provided by the compiler.</p>
<h2><a class="anchor" id="autotoc_md654"></a>
Short Vector Types</h2>
<p >Short vector types derive from the basic integer and floating-point types. They are structures defined in <a class="el" href="hip__vector__types_8h_source.html">hip_vector_types.h</a>. The first, second, third and fourth components of the vector are accessible through the <code>x</code>, <code>y</code>, <code>z</code> and <code>w</code> fields, respectively. All the short vector types support a constructor function of the form <code>make_&lt;type_name&gt;()</code>. For example, <code>float4 make_float4(float x, float y, float z, float w)</code> creates a vector of type <code>float4</code> and value <code>(x,y,z,w)</code>.</p>
<p >HIP supports the following short vector formats:</p><ul>
<li>Signed Integers:<ul>
<li>char1, char2, char3, char4</li>
<li>short1, short2, short3, short4</li>
<li>int1, int2, int3, int4</li>
<li>long1, long2, long3, long4</li>
<li>longlong1, longlong2, longlong3, longlong4</li>
</ul>
</li>
<li>Unsigned Integers:<ul>
<li>uchar1, uchar2, uchar3, uchar4</li>
<li>ushort1, ushort2, ushort3, ushort4</li>
<li>uint1, uint2, uint3, uint4</li>
<li>ulong1, ulong2, ulong3, ulong4</li>
<li>ulonglong1, ulonglong2, ulonglong3, ulonglong4</li>
</ul>
</li>
<li>Floating Points<ul>
<li>float1, float2, float3, float4</li>
<li>double1, double2, double3, double4</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md655"></a>
dim3</h2>
<p >dim3 is a three-dimensional integer vector type commonly used to specify grid and group dimensions. Unspecified dimensions are initialized to 1. </p><div class="fragment"><div class="line">typedef struct dim3 {</div>
<div class="line">  uint32_t x; </div>
<div class="line">  uint32_t y; </div>
<div class="line">  uint32_t z; </div>
<div class="line"> </div>
<div class="line">  dim3(uint32_t _x=1, uint32_t _y=1, uint32_t _z=1) : x(_x), y(_y), z(_z) {};</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md656"></a>
Memory-Fence Instructions</h1>
<p >HIP supports __threadfence() and __threadfence_block().</p>
<p >HIP provides workaround for threadfence_system() under the HIP-Clang path. To enable the workaround, HIP should be built with environment variable HIP_COHERENT_HOST_ALLOC enabled. In addition,the kernels that use __threadfence_system() should be modified as follows:</p><ul>
<li>The kernel should only operate on finegrained system memory; which should be allocated with hipHostMalloc().</li>
<li>Remove all memcpy for those allocated finegrained system memory regions.</li>
</ul>
<h1><a class="anchor" id="autotoc_md657"></a>
Synchronization Functions</h1>
<p >The __syncthreads() built-in function is supported in HIP. The __syncthreads_count(int), __syncthreads_and(int) and __syncthreads_or(int) functions are under development. <br  />
</p>
<h1><a class="anchor" id="autotoc_md658"></a>
Math Functions</h1>
<p >HIP-Clang supports a set of math operations callable from the device.</p>
<h2><a class="anchor" id="autotoc_md659"></a>
Single Precision Mathematical Functions</h2>
<p >Following is the list of supported single precision mathematical functions.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Function</b>   </th><th class="markdownTableHeadNone"><b>Supported on Host</b>   </th><th class="markdownTableHeadNone"><b>Supported on Device</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float acosf ( float x ) <br  />
<sub>Calculate the arc cosine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float acoshf ( float x ) <br  />
<sub>Calculate the nonnegative arc hyperbolic cosine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float asinf ( float x ) <br  />
<sub>Calculate the arc sine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float asinhf ( float x ) <br  />
<sub>Calculate the arc hyperbolic sine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float atan2f ( float y, float x ) <br  />
<sub>Calculate the arc tangent of the ratio of first and second input arguments.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float atanf ( float x ) <br  />
<sub>Calculate the arc tangent of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float atanhf ( float x ) <br  />
<sub>Calculate the arc hyperbolic tangent of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float cbrtf ( float x ) <br  />
<sub>Calculate the cube root of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float ceilf ( float x ) <br  />
<sub>Calculate ceiling of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float copysignf ( float x, float y ) <br  />
<sub>Create value with given magnitude, copying sign of second value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float cosf ( float x ) <br  />
<sub>Calculate the cosine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float coshf ( float x ) <br  />
<sub>Calculate the hyperbolic cosine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float erfcf ( float x ) <br  />
<sub>Calculate the complementary error function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float erff ( float x ) <br  />
<sub>Calculate the error function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float exp10f ( float x ) <br  />
<sub>Calculate the base 10 exponential of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float exp2f ( float x ) <br  />
<sub>Calculate the base 2 exponential of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float expf ( float x ) <br  />
<sub>Calculate the base e exponential of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float expm1f ( float x ) <br  />
<sub>Calculate the base e exponential of the input argument, minus 1.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float fabsf ( float x ) <br  />
<sub>Calculate the absolute value of its argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float fdimf ( float x, float y ) <br  />
<sub>Compute the positive difference between <code>x</code> and <code>y</code>.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float floorf ( float x ) <br  />
<sub>Calculate the largest integer less than or equal to <code>x</code>.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float fmaf ( float x, float y, float z ) <br  />
<sub>Compute <code>x × y + z</code> as a single operation.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float fmaxf ( float x, float y ) <br  />
<sub>Determine the maximum numeric value of the arguments.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float fminf ( float x, float y ) <br  />
<sub>Determine the minimum numeric value of the arguments.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float fmodf ( float x, float y ) <br  />
<sub>Calculate the floating-point remainder of <code>x / y</code>.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float frexpf ( float x, int* nptr ) <br  />
<sub>Extract mantissa and exponent of a floating-point value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✗    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float hypotf ( float x, float y ) <br  />
<sub>Calculate the square root of the sum of squares of two arguments.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int ilogbf ( float x ) <br  />
<sub>Compute the unbiased integer exponent of the argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">__RETURN_TYPE<sup id="a1"><a href="#f1">1</a></sup> isfinite ( float a ) <br  />
<sub>Determine whether argument is finite.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">__RETURN_TYPE<sup><a href="#f1">1</a></sup> isinf ( float a ) <br  />
<sub>Determine whether argument is infinite.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">__RETURN_TYPE<sup><a href="#f1">1</a></sup> isnan ( float a ) <br  />
<sub>Determine whether argument is a NaN.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float ldexpf ( float x, int exp ) <br  />
<sub>Calculate the value of x ⋅ 2<sup>exp</sup>.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float log10f ( float x ) <br  />
<sub>Calculate the base 10 logarithm of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float log1pf ( float x ) <br  />
<sub>Calculate the value of log<sub>e</sub>( 1 + x ).</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float logbf ( float x ) <br  />
<sub>Calculate the floating point representation of the exponent of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float log2f ( float x ) <br  />
<sub>Calculate the base 2 logarithm of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float logf ( float x ) <br  />
<sub>Calculate the natural logarithm of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float modff ( float x, float* iptr ) <br  />
<sub>Break down the input argument into fractional and integral parts.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✗    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float nanf ( const char* tagp ) <br  />
<sub>Returns "Not a Number" value.</sub>   </td><td class="markdownTableBodyNone">✗   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float nearbyintf ( float x ) <br  />
<sub>Round the input argument to the nearest integer.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float powf ( float x, float y ) <br  />
<sub>Calculate the value of first argument to the power of second argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float remainderf ( float x, float y ) <br  />
<sub>Compute single-precision floating-point remainder.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float remquof ( float x, float y, int* quo ) <br  />
<sub>Compute single-precision floating-point remainder and part of quotient.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✗    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float roundf ( float x ) <br  />
<sub>Round to nearest integer value in floating-point.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float scalbnf ( float x, int n ) <br  />
<sub>Scale floating-point input by integer power of two.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">__RETURN_TYPE<sup><a href="#f1">1</a></sup> signbit ( float a ) <br  />
<sub>Return the sign bit of the input.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">void sincosf ( float x, float* sptr, float* cptr ) <br  />
<sub>Calculate the sine and cosine of the first input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✗    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float sinf ( float x ) <br  />
<sub>Calculate the sine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float sinhf ( float x ) <br  />
<sub>Calculate the hyperbolic sine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float sqrtf ( float x ) <br  />
<sub>Calculate the square root of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float tanf ( float x ) <br  />
<sub>Calculate the tangent of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float tanhf ( float x ) <br  />
<sub>Calculate the hyperbolic tangent of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float truncf ( float x ) <br  />
<sub>Truncate input argument to the integral part.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float tgammaf ( float x ) <br  />
<sub>Calculate the gamma function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float erfcinvf ( float y ) <br  />
<sub>Calculate the inverse complementary function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float erfcxf ( float x ) <br  />
<sub>Calculate the scaled complementary error function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float erfinvf ( float y ) <br  />
<sub>Calculate the inverse error function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float fdividef ( float x, float y ) <br  />
<sub>Divide two floating point values.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float frexpf ( float x, int *nptr ) <br  />
<sub>Extract mantissa and exponent of a floating-point value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float j0f ( float x ) <br  />
<sub>Calculate the value of the Bessel function of the first kind of order 0 for the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float j1f ( float x ) <br  />
<sub>Calculate the value of the Bessel function of the first kind of order 1 for the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float jnf ( int n, float x ) <br  />
<sub>Calculate the value of the Bessel function of the first kind of order n for the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float lgammaf ( float x ) <br  />
<sub>Calculate the natural logarithm of the absolute value of the gamma function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">long long int llrintf ( float x ) <br  />
<sub>Round input to nearest integer value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">long long int llroundf ( float x ) <br  />
<sub>Round to nearest integer value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">long int lrintf ( float x ) <br  />
<sub>Round input to nearest integer value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">long int lroundf ( float x ) <br  />
<sub>Round to nearest integer value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float modff ( float x, float *iptr ) <br  />
<sub>Break down the input argument into fractional and integral parts.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float nextafterf ( float x, float y ) <br  />
<sub>Returns next representable single-precision floating-point value after argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float norm3df ( float a, float b, float c ) <br  />
<sub>Calculate the square root of the sum of squares of three coordinates of the argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float norm4df ( float a, float b, float c, float d ) <br  />
<sub>Calculate the square root of the sum of squares of four coordinates of the argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float normcdff ( float y ) <br  />
<sub>Calculate the standard normal cumulative distribution function.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float normcdfinvf ( float y ) <br  />
<sub>Calculate the inverse of the standard normal cumulative distribution function.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float normf ( int dim, const float *a ) <br  />
<sub>Calculate the square root of the sum of squares of any number of coordinates.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float rcbrtf ( float x ) <br  />
<sub>Calculate the reciprocal cube root function.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float remquof ( float x, float y, int *quo ) <br  />
<sub>Compute single-precision floating-point remainder and part of quotient.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float rhypotf ( float x, float y ) <br  />
<sub>Calculate one over the square root of the sum of squares of two arguments.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float rintf ( float x ) <br  />
<sub>Round input to nearest integer value in floating-point.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float rnorm3df ( float a, float b, float c ) <br  />
<sub>Calculate one over the square root of the sum of squares of three coordinates of the argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float rnorm4df ( float a, float b, float c, float d ) <br  />
<sub>Calculate one over the square root of the sum of squares of four coordinates of the argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float rnormf ( int dim, const float *a ) <br  />
<sub>Calculate the reciprocal of square root of the sum of squares of any number of coordinates.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float scalblnf ( float x, long int n ) <br  />
<sub>Scale floating-point input by integer power of two.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">void sincosf ( float x, float *sptr, float *cptr ) <br  />
<sub>Calculate the sine and cosine of the first input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">void sincospif ( float x, float *sptr, float *cptr ) <br  />
<sub>Calculate the sine and cosine of the first input argument multiplied by PI.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float y0f ( float x ) <br  />
<sub>Calculate the value of the Bessel function of the second kind of order 0 for the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float y1f ( float x ) <br  />
<sub>Calculate the value of the Bessel function of the second kind of order 1 for the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float ynf ( int n, float x ) <br  />
<sub>Calculate the value of the Bessel function of the second kind of order n for the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓   </td></tr>
</table>
<p ><sub><b id="f1"><sup>[1]</sup></b> __RETURN_TYPE is dependent on compiler. It is usually 'int' for C compilers and 'bool' for C++ compilers.</sub> <a href="#a1">↩</a></p>
<h2><a class="anchor" id="autotoc_md660"></a>
Double Precision Mathematical Functions</h2>
<p >Following is the list of supported double precision mathematical functions.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Function</b>   </th><th class="markdownTableHeadNone"><b>Supported on Host</b>   </th><th class="markdownTableHeadNone"><b>Supported on Device</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double acos ( double x ) <br  />
<sub>Calculate the arc cosine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double acosh ( double x ) <br  />
<sub>Calculate the nonnegative arc hyperbolic cosine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double asin ( double x ) <br  />
<sub>Calculate the arc sine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double asinh ( double x ) <br  />
<sub> Calculate the arc hyperbolic sine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double atan ( double x ) <br  />
<sub>Calculate the arc tangent of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double atan2 ( double y, double x ) <br  />
<sub>Calculate the arc tangent of the ratio of first and second input arguments.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double atanh ( double x ) <br  />
<sub>Calculate the arc hyperbolic tangent of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double cbrt ( double x ) <br  />
<sub>Calculate the cube root of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double ceil ( double x ) <br  />
<sub>Calculate ceiling of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double copysign ( double x, double y ) <br  />
<sub>Create value with given magnitude, copying sign of second value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double cos ( double x ) <br  />
<sub>Calculate the cosine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double cosh ( double x ) <br  />
<sub>Calculate the hyperbolic cosine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double erf ( double x ) <br  />
<sub>Calculate the error function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double erfc ( double x ) <br  />
<sub>Calculate the complementary error function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double exp ( double x ) <br  />
<sub>Calculate the base e exponential of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double exp10 ( double x ) <br  />
<sub>Calculate the base 10 exponential of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double exp2 ( double x ) <br  />
<sub>Calculate the base 2 exponential of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double expm1 ( double x ) <br  />
<sub>Calculate the base e exponential of the input argument, minus 1.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double fabs ( double x ) <br  />
<sub>Calculate the absolute value of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double fdim ( double x, double y ) <br  />
<sub>Compute the positive difference between <code>x</code> and <code>y</code>.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double floor ( double x ) <br  />
<sub>Calculate the largest integer less than or equal to <code>x</code>.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double fma ( double x, double y, double z ) <br  />
<sub>Compute <code>x × y + z</code> as a single operation.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double fmax ( double , double ) <br  />
<sub>Determine the maximum numeric value of the arguments.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double fmin ( double x, double y ) <br  />
<sub>Determine the minimum numeric value of the arguments.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double fmod ( double x, double y ) <br  />
<sub>Calculate the floating-point remainder of <code>x / y</code>.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double frexp ( double x, int* nptr ) <br  />
<sub>Extract mantissa and exponent of a floating-point value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✗    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double hypot ( double x, double y ) <br  />
<sub>Calculate the square root of the sum of squares of two arguments.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int ilogb ( double x ) <br  />
<sub>Compute the unbiased integer exponent of the argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">__RETURN_TYPE<sup id="a2"><a href="#f2">1</a></sup> isfinite ( double a ) <br  />
<sub>Determine whether argument is finite.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">__RETURN_TYPE<sup><a href="#f2">1</a></sup> isinf ( double a ) <br  />
<sub>Determine whether argument is infinite.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">__RETURN_TYPE<sup><a href="#f2">1</a></sup> isnan ( double a ) <br  />
<sub>Determine whether argument is a NaN.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double ldexp ( double x, int exp ) <br  />
<sub>Calculate the value of x ⋅ 2<sup>exp</sup>.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double log ( double x ) <br  />
<sub>Calculate the base e logarithm of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double log10 ( double x ) <br  />
<sub>Calculate the base 10 logarithm of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double log1p ( double x ) <br  />
<sub>Calculate the value of log<sub>e</sub>( 1 + x ).</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double log2 ( double x ) <br  />
<sub>Calculate the base 2 logarithm of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double logb ( double x ) <br  />
<sub>Calculate the floating point representation of the exponent of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double modf ( double x, double* iptr ) <br  />
<sub>Break down the input argument into fractional and integral parts.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✗    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double nan ( const char* tagp ) <br  />
<sub>Returns "Not a Number" value.</sub>   </td><td class="markdownTableBodyNone">✗   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double nearbyint ( double x ) <br  />
<sub>Round the input argument to the nearest integer.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double pow ( double x, double y ) <br  />
<sub>Calculate the value of first argument to the power of second argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double remainder ( double x, double y ) <br  />
<sub>Compute double-precision floating-point remainder.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double remquo ( double x, double y, int* quo ) <br  />
<sub>Compute double-precision floating-point remainder and part of quotient.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✗    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double round ( double x ) <br  />
<sub>Round to nearest integer value in floating-point.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double scalbn ( double x, int n ) <br  />
<sub>Scale floating-point input by integer power of two.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">__RETURN_TYPE<sup><a href="#f2">1</a></sup> signbit ( double a ) <br  />
<sub>Return the sign bit of the input.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double sin ( double x ) <br  />
<sub>Calculate the sine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">void sincos ( double x, double* sptr, double* cptr ) <br  />
<sub>Calculate the sine and cosine of the first input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✗    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double sinh ( double x ) <br  />
<sub>Calculate the hyperbolic sine of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double sqrt ( double x ) <br  />
<sub>Calculate the square root of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double tan ( double x ) <br  />
<sub>Calculate the tangent of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double tanh ( double x ) <br  />
<sub>Calculate the hyperbolic tangent of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double tgamma ( double x ) <br  />
<sub>Calculate the gamma function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double trunc ( double x ) <br  />
<sub>Truncate input argument to the integral part.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double erfcinv ( double y ) <br  />
<sub>Calculate the inverse complementary function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double erfcx ( double x ) <br  />
<sub>Calculate the scaled complementary error function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double erfinv ( double y ) <br  />
<sub>Calculate the inverse error function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double frexp ( float x, int *nptr ) <br  />
<sub>Extract mantissa and exponent of a floating-point value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double j0 ( double x ) <br  />
<sub>Calculate the value of the Bessel function of the first kind of order 0 for the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double j1 ( double x ) <br  />
<sub>Calculate the value of the Bessel function of the first kind of order 1 for the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double jn ( int n, double x ) <br  />
<sub>Calculate the value of the Bessel function of the first kind of order n for the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double lgamma ( double x ) <br  />
<sub>Calculate the natural logarithm of the absolute value of the gamma function of the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">long long int llrint ( double x ) <br  />
<sub>Round input to nearest integer value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">long long int llround ( double x ) <br  />
<sub>Round to nearest integer value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">long int lrint ( double x ) <br  />
<sub>Round input to nearest integer value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">long int lround ( double x ) <br  />
<sub>Round to nearest integer value.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double modf ( double x, double *iptr ) <br  />
<sub>Break down the input argument into fractional and integral parts.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double nextafter ( double x, double y ) <br  />
<sub>Returns next representable single-precision floating-point value after argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double norm3d ( double a, double b, double c ) <br  />
<sub>Calculate the square root of the sum of squares of three coordinates of the argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float norm4d ( double a, double b, double c, double d ) <br  />
<sub>Calculate the square root of the sum of squares of four coordinates of the argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double normcdf ( double y ) <br  />
<sub>Calculate the standard normal cumulative distribution function.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double normcdfinv ( double y ) <br  />
<sub>Calculate the inverse of the standard normal cumulative distribution function.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double rcbrt ( double x ) <br  />
<sub>Calculate the reciprocal cube root function.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double remquo ( double x, double y, int *quo ) <br  />
<sub>Compute single-precision floating-point remainder and part of quotient.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double rhypot ( double x, double y ) <br  />
<sub>Calculate one over the square root of the sum of squares of two arguments.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double rint ( double x ) <br  />
<sub>Round input to nearest integer value in floating-point.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double rnorm3d ( double a, double b, double c ) <br  />
<sub>Calculate one over the square root of the sum of squares of three coordinates of the argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double rnorm4d ( double a, double b, double c, double d ) <br  />
<sub>Calculate one over the square root of the sum of squares of four coordinates of the argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double rnorm ( int dim, const double *a ) <br  />
<sub>Calculate the reciprocal of square root of the sum of squares of any number of coordinates.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double scalbln ( double x, long int n ) <br  />
<sub>Scale floating-point input by integer power of two.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">void sincos ( double x, double *sptr, double *cptr ) <br  />
<sub>Calculate the sine and cosine of the first input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">void sincospi ( double x, double *sptr, double *cptr ) <br  />
<sub>Calculate the sine and cosine of the first input argument multiplied by PI.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double y0f ( double x ) <br  />
<sub>Calculate the value of the Bessel function of the second kind of order 0 for the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double y1 ( double x ) <br  />
<sub>Calculate the value of the Bessel function of the second kind of order 1 for the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double yn ( int n, double x ) <br  />
<sub>Calculate the value of the Bessel function of the second kind of order n for the input argument.</sub>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓   </td></tr>
</table>
<p ><sub><b id="f2"><sup>[1]</sup></b> __RETURN_TYPE is dependent on compiler. It is usually 'int' for C compilers and 'bool' for C++ compilers.</sub> <a href="#a2">↩</a></p>
<h2><a class="anchor" id="autotoc_md661"></a>
Integer Intrinsics</h2>
<p >Following is the list of supported integer intrinsics. Note that intrinsics are supported on device only.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Function</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int __brev ( unsigned int x ) <br  />
<sub>Reverse the bit order of a 32 bit unsigned integer.</sub>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned long long int __brevll ( unsigned long long int x ) <br  />
<sub>Reverse the bit order of a 64 bit unsigned integer. </sub>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int __clz ( int x ) <br  />
<sub>Return the number of consecutive high-order zero bits in a 32 bit integer.</sub>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int __clz(unsigned int x) <br  />
<sub>Return the number of consecutive high-order zero bits in 32 bit unsigned integer.</sub>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int __clzll ( long long int x ) <br  />
<sub>Count the number of consecutive high-order zero bits in a 64 bit integer.</sub>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int __clzll(long long int x) <br  />
<sub>Return the number of consecutive high-order zero bits in 64 bit signed integer.</sub>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int __ffs(unsigned int x) <br  />
<sub>Find the position of least signigicant bit set to 1 in a 32 bit unsigned integer.<sup id="a3"><a href="#f3">1</a></sup></sub>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int __ffs(int x) <br  />
<sub>Find the position of least signigicant bit set to 1 in a 32 bit signed integer.</sub>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int __ffsll(unsigned long long int x) <br  />
<sub>Find the position of least signigicant bit set to 1 in a 64 bit unsigned integer.<sup><a href="#f3">1</a></sup></sub>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int __ffsll(long long int x) <br  />
<sub>Find the position of least signigicant bit set to 1 in a 64 bit signed integer.</sub>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int __popc ( unsigned int x ) <br  />
<sub>Count the number of bits that are set to 1 in a 32 bit integer.</sub>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int __popcll ( unsigned long long int x )<br  />
<sub>Count the number of bits that are set to 1 in a 64 bit integer.</sub>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int __mul24 ( int x, int y )<br  />
<sub>Multiply two 24bit integers.</sub>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int __umul24 ( unsigned int x, unsigned int y )<br  />
<sub>Multiply two 24bit unsigned integers.</sub>   </td></tr>
</table>
<p><sub><b id="f3"><sup>[1]</sup></b> The HIP-Clang implementation of __ffs() and __ffsll() contains code to add a constant +1 to produce the ffs result format. For the cases where this overhead is not acceptable and programmer is willing to specialize for the platform, HIP-Clang provides __lastbit_u32_u32(unsigned int input) and __lastbit_u32_u64(unsigned long long int input). The index returned by __lastbit_ instructions starts at -1, while for ffs the index starts at 0.</sub></p>
<p ><sub></sub></p>
<h2><a class="anchor" id="autotoc_md662"></a>
Floating-point Intrinsics</h2>
<p ><sub>Following is the list of supported floating-point intrinsics. Note that intrinsics are supported on device only.</sub></p>
<p ><sub></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Function</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float __cosf ( float x ) <br  />
<sub>Calculate the fast approximate cosine of the input argument.</sub>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float __expf ( float x ) <br  />
<sub>Calculate the fast approximate base e exponential of the input argument.</sub>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float __frsqrt_rn ( float x ) <br  />
<sub>Compute <code>1 / √x</code> in round-to-nearest-even mode.</sub>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float __fsqrt_rn ( float x ) <br  />
<sub>Compute <code>√x</code> in round-to-nearest-even mode.</sub>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float __log10f ( float x ) <br  />
<sub>Calculate the fast approximate base 10 logarithm of the input argument.</sub>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float __log2f ( float x ) <br  />
<sub>Calculate the fast approximate base 2 logarithm of the input argument.</sub>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float __logf ( float x ) <br  />
<sub>Calculate the fast approximate base e logarithm of the input argument.</sub>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float __powf ( float x, float y ) <br  />
<sub>Calculate the fast approximate of x<sup>y</sup>.</sub>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float __sinf ( float x ) <br  />
<sub>Calculate the fast approximate sine of the input argument.</sub>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float __tanf ( float x ) <br  />
<sub>Calculate the fast approximate tangent of the input argument.</sub>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double __dsqrt_rn ( double x ) <br  />
<sub>Compute <code>√x</code> in round-to-nearest-even mode.</sub>   </td></tr>
</table>
<p></sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md663"></a>
Texture Functions</h1>
<p ><sub>The supported Texture functions are listed in header files "texture_functions.h"(<a href="https://github.com/ROCm-Developer-Tools/HIP/blob/main/include/hip/hcc_detail/texture_functions.h">https://github.com/ROCm-Developer-Tools/HIP/blob/main/include/hip/hcc_detail/texture_functions.h</a>) and"texture_indirect_functions.h" (<a href="https://github.com/ROCm-Developer-Tools/HIP/blob/main/include/hip/hcc_detail/texture_indirect_functions.h">https://github.com/ROCm-Developer-Tools/HIP/blob/main/include/hip/hcc_detail/texture_indirect_functions.h</a>).</sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md664"></a>
Surface Functions</h1>
<p ><sub>Surface functions are not supported.</sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md665"></a>
Timer Functions</h1>
<p ><sub>HIP provides the following built-in functions for reading a high-resolution timer from the device. </p><div class="fragment"><div class="line">clock_t clock()</div>
<div class="line">long long int clock64()</div>
</div><!-- fragment --><p> Returns the value of counter that is incremented every clock cycle on device. Difference in values returned provides the cycles used.</sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md666"></a>
Atomic Functions</h1>
<p ><sub> Atomic functions execute as read-modify-write operations residing in global or shared memory. No other device or thread can observe or modify the memory location during an atomic operation. If multiple instructions from different devices or threads target the same memory location, the instructions are serialized in an undefined order.</sub></p>
<p ><sub>HIP adds new APIs with _system as suffix to support system scope atomic operations. For example, atomicAnd atomic is dedicated to the GPU device, atomicAnd_system will allow developers to extend the atomic operation to system scope, from the GPU device to other CPUs and GPU devices in the system. <br  />
</sub></p>
<p ><sub>HIP supports the following atomic operations.</sub></p>
<p ><sub></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Function</b>   </th><th class="markdownTableHeadNone"><b>Supported in HIP</b>   </th><th class="markdownTableHeadNone"><b>Supported in CUDA</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int atomicAdd(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int atomicAdd_system(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int atomicAdd(unsigned int* address,unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int atomicAdd_system(unsigned int* address, unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned long long atomicAdd(unsigned long long* address,unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned long long atomicAdd_system(unsigned long long* address, unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float atomicAdd(float* address, float val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float atomicAdd_system(float* address, float val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double atomicAdd(double* address, double val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">double atomicAdd_system(double* address, double val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int atomicSub(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int atomicSub_system(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int atomicSub(unsigned int* address,unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int atomicSub_system(unsigned int* address, unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int atomicExch(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int atomicExch_system(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int atomicExch(unsigned int* address,unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int atomicExch_system(unsigned int* address, unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned long long atomicExch(unsigned long long int* address,unsigned long long int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned long long atomicExch_system(unsigned long long* address, unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned long long atomicExch_system(unsigned long long* address, unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">float atomicExch(float* address, float val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int atomicMin(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int atomicMin_system(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int atomicMin(unsigned int* address,unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int atomicMin_system(unsigned int* address, unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned long long atomicMin(unsigned long long* address,unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int atomicMax(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int atomicMax_system(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int atomicMax(unsigned int* address,unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int atomicMax_system(unsigned int* address, unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned long long atomicMax(unsigned long long* address,unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int atomicInc(unsigned int* address)   </td><td class="markdownTableBodyNone">✗   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int atomicDec(unsigned int* address)   </td><td class="markdownTableBodyNone">✗   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int atomicCAS(int* address, int compare, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int atomicCAS_system(int* address, int compare, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int atomicCAS(unsigned int* address,unsigned int compare,unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int atomicCAS_system(unsigned int* address, unsigned int compare, unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned long long atomicCAS(unsigned long long* address,unsigned long long compare,unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned long long atomicCAS_system(unsigned long long* address, unsigned long long compare, unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int atomicAnd(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int atomicAnd_system(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int atomicAnd(unsigned int* address,unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int atomicAnd_system(unsigned int* address, unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned long long atomicAnd(unsigned long long* address,unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned long long atomicAnd_system(unsigned long long* address, unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int atomicOr(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int atomicOr_system(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int atomicOr(unsigned int* address,unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int atomicOr_system(unsigned int* address, unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int atomicOr_system(unsigned int* address, unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned long long atomicOr(unsigned long long int* address,unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned long long atomicOr_system(unsigned long long* address, unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int atomicXor(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int atomicXor_system(int* address, int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned int atomicXor(unsigned int* address,unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned int atomicXor_system(unsigned int* address, unsigned int val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unsigned long long atomicXor(unsigned long long* address,unsigned long long val))   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unsigned long long atomicXor_system(unsigned long long* address, unsigned long long val)   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓   </td></tr>
</table>
<p></sub></p>
<p ><sub>Note, in order to keep backwards compitability in float/double atomicAdd functions, in ROCm4.4 release, we introduce a new compilation flag as an option in CMake file, __HIP_USE_CMPXCHG_FOR_FP_ATOMICS</sub></p>
<p ><sub>By default, this compilation flag is not set("0"), so hip runtime will use current float/double atomicAdd functions. If this compilation flag is set to "1", that is, with the cmake option "-D__HIP_USE_CMPXCHG_FOR_FP_ATOMICS=1", the old float/double atomicAdd functions will be used instead, for compatibility with compilers not supporting floating point atomics. For details steps how to build hip runtime, please refer to the section "build HIPAMD" (<a href="https://github.com/ROCm-Developer-Tools/hipamd/blob/develop/INSTALL.md">https://github.com/ROCm-Developer-Tools/hipamd/blob/develop/INSTALL.md</a>).</sub></p>
<p ><sub></sub></p>
<h2><a class="anchor" id="autotoc_md667"></a>
Caveats and Features Under-Development:</h2>
<p ><sub></p><ul>
<li>HIP enables atomic operations on 32-bit integers. Additionally, it supports an atomic float add. AMD hardware, however, implements the float add using a CAS loop, so this function may not perform efficiently.</li>
</ul>
<p></sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md668"></a>
Warp Cross-Lane Functions</h1>
<p ><sub> Warp cross-lane functions operate across all lanes in a warp. The hardware guarantees that all warp lanes will execute in lockstep, so additional synchronization is unnecessary, and the instructions use no shared memory.</sub></p>
<p ><sub>Note that Nvidia and AMD devices have different warp sizes, so portable code should use the warpSize built-ins to query the warp size. Hipified code from the Cuda path requires careful review to ensure it doesn’t assume a waveSize of 32. "Wave-aware" code that assumes a waveSize of 32 will run on a wave-64 machine, but it will utilize only half of the machine resources. WarpSize built-ins should only be used in device functions and its value depends on GPU arch. Users should not assume warpSize to be a compile-time constant. Host functions should use hipGetDeviceProperties to get the default warp size of a GPU device:</sub></p>
<p ><sub></p><div class="fragment"><div class="line">cudaDeviceProp props;</div>
<div class="line">cudaGetDeviceProperties(&amp;props, deviceID);</div>
<div class="line">int w = props.warpSize;</div>
<div class="line">// implement portable algorithm based on w (rather than assume 32 or 64)</div>
</div><!-- fragment --><p></sub></p>
<p ><sub>Note that assembly kernels may be built for a warp size which is different than the default warp size.</sub></p>
<p ><sub></sub></p>
<h2><a class="anchor" id="autotoc_md669"></a>
Warp Vote and Ballot Functions</h2>
<p ><sub> </p><div class="fragment"><div class="line">int __all(int predicate)</div>
<div class="line">int __any(int predicate)</div>
<div class="line">uint64_t __ballot(int predicate)</div>
</div><!-- fragment --><p></sub></p>
<p ><sub>Threads in a warp are referred to as <em>lanes</em> and are numbered from 0 to warpSize &ndash; 1. For these functions, each warp lane contributes 1 &ndash; the bit value (the predicate), which is efficiently broadcast to all lanes in the warp. The 32-bit int predicate from each lane reduces to a 1-bit value: 0 (predicate = 0) or 1 (predicate != 0). <code>__any</code> and <code>__all</code> provide a summary view of the predicates that the other warp lanes contribute:</sub></p>
<p ><sub></p><ul>
<li><code>__any()</code> returns 1 if any warp lane contributes a nonzero predicate, or 0 otherwise</li>
<li><code>__all()</code> returns 1 if all other warp lanes contribute nonzero predicates, or 0 otherwise</li>
</ul>
<p></sub></p>
<p ><sub>Applications can test whether the target platform supports the any/all instruction using the <code>hasWarpVote</code> device property or the HIP_ARCH_HAS_WARP_VOTE compiler define.</sub></p>
<p ><sub><code>__ballot</code> provides a bit mask containing the 1-bit predicate value from each lane. The nth bit of the result contains the 1 bit contributed by the nth warp lane. Note that HIP's <code>__ballot</code> function supports a 64-bit return value (compared with Cuda’s 32 bits). Code ported from Cuda should support the larger warp sizes that the HIP version of this instruction supports. Applications can test whether the target platform supports the ballot instruction using the <code>hasWarpBallot</code> device property or the HIP_ARCH_HAS_WARP_BALLOT compiler define.</sub></p>
<p ><sub></sub></p>
<h2><a class="anchor" id="autotoc_md670"></a>
Warp Shuffle Functions</h2>
<p ><sub> Half-float shuffles are not supported. The default width is warpSize&mdash;see <a href="#warp-cross-lane-functions">Warp Cross-Lane Functions</a>. Applications should not assume the warpSize is 32 or 64.</sub></p>
<p ><sub></p><div class="fragment"><div class="line">int   __shfl      (int var,   int srcLane, int width=warpSize);</div>
<div class="line">float __shfl      (float var, int srcLane, int width=warpSize);</div>
<div class="line">int   __shfl_up   (int var,   unsigned int delta, int width=warpSize);</div>
<div class="line">float __shfl_up   (float var, unsigned int delta, int width=warpSize);</div>
<div class="line">int   __shfl_down (int var,   unsigned int delta, int width=warpSize);</div>
<div class="line">float __shfl_down (float var, unsigned int delta, int width=warpSize);</div>
<div class="line">int   __shfl_xor  (int var,   int laneMask, int width=warpSize);</div>
<div class="line">float __shfl_xor  (float var, int laneMask, int width=warpSize);</div>
</div><!-- fragment --><p></sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md671"></a>
Cooperative Groups Functions</h1>
<p ><sub> Cooperative groups is a mechanism for forming and communicating between groups of threads at a granularity different than the block. This feature was introduced in Cuda 9.</sub></p>
<p ><sub>HIP supports the following kernel language cooperative groups types or functions.</sub></p>
<p ><sub></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Function</b>   </th><th class="markdownTableHeadNone"><b>Supported in HIP</b>   </th><th class="markdownTableHeadNone"><b>Supported in CUDA</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>void thread_group.sync();</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>unsigned thread_group.size();</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>unsigned thread_group.thread_rank()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>bool thread_group.is_valid();</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>grid_group this_grid()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>void grid_group.sync()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>unsigned grid_group.size()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>unsigned grid_group.thread_rank()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>bool grid_group.is_valid()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>multi_grid_group this_multi_grid()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>void multi_grid_group.sync()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>unsigned multi_grid_group.size()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>unsigned multi_grid_group.thread_rank()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>bool multi_grid_group.is_valid()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>unsigned multi_grid_group.num_grids()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>unsigned multi_grid_group.grid_rank()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>thread_block this_thread_block()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>multi_grid_group this_multi_grid()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>void multi_grid_group.sync()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>void thread_block.sync()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>unsigned thread_block.size()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>unsigned thread_block.thread_rank()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>bool thread_block.is_valid()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>dim3 thread_block.group_index()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>dim3 thread_block.thread_index()</code>   </td><td class="markdownTableBodyNone">✓   </td><td class="markdownTableBodyNone">✓   </td></tr>
</table>
<p></sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md672"></a>
Warp Matrix Functions</h1>
<p ><sub> Warp matrix functions allow a warp to cooperatively operate on small matrices whose elements are spread over the lanes in an unspecified manner. This feature was introduced in Cuda 9.</sub></p>
<p ><sub>HIP does not support any of the kernel language warp matrix types or functions.</sub></p>
<p ><sub></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Function</b>   </th><th class="markdownTableHeadNone"><b>Supported in HIP</b>   </th><th class="markdownTableHeadNone"><b>Supported in CUDA</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>void load_matrix_sync(fragment&lt;...&gt; &amp;a, const T* mptr, unsigned lda)</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>void load_matrix_sync(fragment&lt;...&gt; &amp;a, const T* mptr, unsigned lda, layout_t layout)</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>void store_matrix_sync(T* mptr, fragment&lt;...&gt; &amp;a, unsigned lda, layout_t layout)</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>void fill_fragment(fragment&lt;...&gt; &amp;a, const T &amp;value)</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">✓    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>void mma_sync(fragment&lt;...&gt; &amp;d, const fragment&lt;...&gt; &amp;a, const fragment&lt;...&gt; &amp;b, const fragment&lt;...&gt; &amp;c , bool sat)</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">✓   </td></tr>
</table>
<p></sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md673"></a>
Independent Thread Scheduling</h1>
<p ><sub> The hardware support for independent thread scheduling introduced in certain architectures supporting Cuda allows threads to progress independently of each other and enables intra-warp synchronizations that were previously not allowed.</sub></p>
<p ><sub>HIP does not support this type of scheduling.</sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md674"></a>
Profiler Counter Function</h1>
<p ><sub> The Cuda <code>__prof_trigger()</code> instruction is not supported.</sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md675"></a>
Assert</h1>
<p ><sub> The assert function is under development. HIP does support an "abort" call which will terminate the process execution from inside the kernel.</sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md676"></a>
Printf</h1>
<p ><sub> The printf function is under development.</sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md677"></a>
Device-Side Dynamic Global Memory Allocation</h1>
<p ><sub> Device-side dynamic global memory allocation is under development. HIP now includes a preliminary implementation of malloc and free that can be called from device functions.</sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md678"></a>
&lt;tt&gt;__launch_bounds__&lt;/tt&gt;</h1>
<p ><sub></sub></p>
<p ><sub>GPU multiprocessors have a fixed pool of resources (primarily registers and shared memory) which are shared by the actively running warps. Using more resources can increase IPC of the kernel but reduces the resources available for other warps and limits the number of warps that can be simulaneously running. Thus GPUs have a complex relationship between resource usage and performance.</sub></p>
<p ><sub><b>launch_bounds</b> allows the application to provide usage hints that influence the resources (primarily registers) used by the generated code. It is a function attribute that must be attached to a <b>global</b> function:</sub></p>
<p ><sub></p><div class="fragment"><div class="line">__global__ void `__launch_bounds__`(MAX_THREADS_PER_BLOCK, MIN_WARPS_PER_EU) MyKernel(...) ...</div>
<div class="line">MyKernel(hipGridLaunch lp, ...)</div>
<div class="line">...</div>
</div><!-- fragment --><p></sub></p>
<p ><sub><b>launch_bounds</b> supports two parameters:</p><ul>
<li>MAX_THREADS_PER_BLOCK - The programmers guarantees that kernel will be launched with threads less than MAX_THREADS_PER_BLOCK. (On NVCC this maps to the .maxntid PTX directive). If no launch_bounds is specified, MAX_THREADS_PER_BLOCK is the maximum block size supported by the device (typically 1024 or larger). Specifying MAX_THREADS_PER_BLOCK less than the maximum effectively allows the compiler to use more resources than a default unconstrained compilation that supports all possible block sizes at launch time. The threads-per-block is the product of (hipBlockDim_x * hipBlockDim_y * hipBlockDim_z).</li>
<li>MIN_WARPS_PER_EU - directs the compiler to minimize resource usage so that the requested number of warps can be simultaneously active on a multi-processor. Since active warps compete for the same fixed pool of resources, the compiler must reduce resources required by each warp(primarily registers). MIN_WARPS_PER_EU is optional and defaults to 1 if not specified. Specifying a MIN_WARPS_PER_EU greater than the default 1 effectively constrains the compiler's resource usage.</li>
</ul>
<p></sub></p>
<p ><sub>When launch kernel with HIP APIs, for example, hipModuleLaunchKernel(), HIP will do validation to make sure input kernel dimension size is not larger than specified launch_bounds. In case exceeded, HIP would return launch failure, if AMD_LOG_LEVEL is set with proper value (for details, please refer to docs/markdown/hip_logging.md), detail information will be shown in the error log message, including launch parameters of kernel dim size, launch bounds, and the name of the faulting kernel. It's helpful to figure out which is the faulting kernel, besides, the kernel dim size and launch bounds values will also assist in debugging such failures.</sub></p>
<p ><sub></sub></p>
<h2><a class="anchor" id="autotoc_md679"></a>
Compiler Impact</h2>
<p ><sub>The compiler uses these parameters as follows:</p><ul>
<li>The compiler uses the hints only to manage register usage, and does not automatically reduce shared memory or other resources.</li>
<li>Compilation fails if compiler cannot generate a kernel which meets the requirements of the specified launch bounds.</li>
<li>From MAX_THREADS_PER_BLOCK, the compiler derives the maximum number of warps/block that can be used at launch time. Values of MAX_THREADS_PER_BLOCK less than the default allows the compiler to use a larger pool of registers : each warp uses registers, and this hint constains the launch to a warps/block size which is less than maximum.</li>
<li>From MIN_WARPS_PER_EU, the compiler derives a maximum number of registers that can be used by the kernel (to meet the required #simultaneous active blocks). If MIN_WARPS_PER_EU is 1, then the kernel can use all registers supported by the multiprocessor.</li>
<li>The compiler ensures that the registers used in the kernel is less than both allowed maximums, typically by spilling registers (to shared or global memory), or by using more instructions.</li>
<li>The compiler may use hueristics to increase register usage, or may simply be able to avoid spilling. The MAX_THREADS_PER_BLOCK is particularly useful in this cases, since it allows the compiler to use more registers and avoid situations where the compiler constrains the register usage (potentially spilling) to meet the requirements of a large block size that is never used at launch time.</li>
</ul>
<p></sub></p>
<p ><sub></sub></p>
<h2><a class="anchor" id="autotoc_md680"></a>
CU and EU Definitions</h2>
<p ><sub><a class="el" href="class_a.html">A</a> compute unit (CU) is responsible for executing the waves of a work-group. It is composed of one or more execution units (EU) which are responsible for executing waves. An EU can have enough resources to maintain the state of more than one executing wave. This allows an EU to hide latency by switching between waves in a similar way to symmetric multithreading on a CPU. In order to allow the state for multiple waves to fit on an EU, the resources used by a single wave have to be limited. Limiting such resources can allow greater latency hiding, but can result in having to spill some register state to memory. This attribute allows an advanced developer to tune the number of waves that are capable of fitting within the resources of an EU. It can be used to ensure at least a certain number will fit to help hide latency, and can also be used to ensure no more than a certain number will fit to limit cache thrashing.</sub></p>
<p ><sub></sub></p>
<h2><a class="anchor" id="autotoc_md681"></a>
Porting from CUDA __launch_bounds</h2>
<p ><sub>CUDA defines a __launch_bounds which is also designed to control occupancy: </p><div class="fragment"><div class="line">__launch_bounds(MAX_THREADS_PER_BLOCK, MIN_BLOCKS_PER_MULTIPROCESSOR)</div>
</div><!-- fragment --><p></sub></p>
<p ><sub></p><ul>
<li>The second parameter __launch_bounds parameters must be converted to the format used __hip_launch_bounds, which uses warps and execution-units rather than blocks and multi-processors (this conversion is performed automatically by hipify tools). <div class="fragment"><div class="line">MIN_WARPS_PER_EXECUTION_UNIT = (MIN_BLOCKS_PER_MULTIPROCESSOR * MAX_THREADS_PER_BLOCK) / 32</div>
</div><!-- fragment --></li>
</ul>
<p></sub></p>
<p ><sub>The key differences in the interface are:</p><ul>
<li>Warps (rather than blocks): The developer is trying to tell the compiler to control resource utilization to guarantee some amount of active Warps/EU for latency hiding. Specifying active warps in terms of blocks appears to hide the micro-architectural details of the warp size, but makes the interface more confusing since the developer ultimately needs to compute the number of warps to obtain the desired level of control.</li>
<li>Execution Units (rather than multiProcessor): The use of execution units rather than multiprocessors provides support for architectures with multiple execution units/multi-processor. For example, the AMD GCN architecture has 4 execution units per multiProcessor. The hipDeviceProps has a field executionUnitsPerMultiprocessor. Platform-specific coding techniques such as #ifdef can be used to specify different launch_bounds for NVCC and HIP-Clang platforms, if desired.</li>
</ul>
<p></sub></p>
<p ><sub></sub></p>
<h2><a class="anchor" id="autotoc_md682"></a>
maxregcount</h2>
<p ><sub>Unlike nvcc, HIP-Clang does not support the "--maxregcount" option. Instead, users are encouraged to use the hip_launch_bounds directive since the parameters are more intuitive and portable than micro-architecture details like registers, and also the directive allows per-kernel control rather than an entire file. hip_launch_bounds works on both HIP-Clang and nvcc targets.</sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md683"></a>
Register Keyword</h1>
<p ><sub>The register keyword is deprecated in C++, and is silently ignored by both nvcc and HIP-Clang. You can pass the option <code>-Wdeprecated-register</code> the compiler warning message.</sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md684"></a>
Pragma Unroll</h1>
<p ><sub> Unroll with a bounds that is known at compile-time is supported. For example:</sub></p>
<p ><sub></p><div class="fragment"><div class="line">#pragma unroll 16 /* hint to compiler to unroll next loop by 16 */</div>
<div class="line">for (int i=0; i&lt;16; i++) ...</div>
</div><!-- fragment --><p></sub></p>
<p ><sub></p><div class="fragment"><div class="line">#pragma unroll 1  /* tell compiler to never unroll the loop */</div>
<div class="line">for (int i=0; i&lt;16; i++) ...</div>
</div><!-- fragment --><p></sub></p>
<p ><sub></p><div class="fragment"><div class="line">#pragma unroll /* hint to compiler to completely unroll next loop. */</div>
<div class="line">for (int i=0; i&lt;16; i++) ...</div>
</div><!-- fragment --><p></sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md685"></a>
In-Line Assembly</h1>
<p ><sub> GCN ISA In-line assembly, is supported. For example:</sub></p>
<p ><sub></p><div class="fragment"><div class="line">asm volatile (&quot;v_mac_f32_e32 %0, %2, %3&quot; : &quot;=v&quot; (out[i]) : &quot;0&quot;(out[i]), &quot;v&quot; (a), &quot;v&quot; (in[i]));</div>
</div><!-- fragment --><p></sub></p>
<p ><sub>We insert the GCN isa into the kernel using <code>asm()</code> Assembler statement. <code>volatile</code> keyword is used so that the optimizers must not change the number of volatile operations or change their order of execution relative to other volatile operations. <code>v_mac_f32_e32</code> is the GCN instruction, for more information please refer - <a href="http://gpuopen.com/compute-product/amd-gcn3-isa-architecture-manual/">AMD GCN3 ISA architecture manual</a> Index for the respective operand in the ordered fashion is provided by <code>%</code> followed by position in the list of operands <code>"v"</code> is the constraint code (for target-specific AMDGPU) for 32-bit VGPR register, for more info please refer - <a href="https://llvm.org/docs/LangRef.html#supported-constraint-code-list">Supported Constraint Code List for AMDGPU</a> Output Constraints are specified by an <code>"="</code> prefix as shown above ("=v"). This indicate that assemby will write to this operand, and the operand will then be made available as a return value of the asm expression. Input constraints do not have a prefix - just the constraint code. The constraint string of <code>"0"</code> says to use the assigned register for output as an input as well (it being the 0'th constraint).</sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md686"></a>
C++ Support</h1>
<p ><sub>The following C++ features are not supported:</p><ul>
<li>Run-time-type information (RTTI)</li>
<li>Virtual functions</li>
<li>Try/catch</li>
</ul>
<p></sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md687"></a>
Kernel Compilation</h1>
<p ><sub>hipcc now supports compiling C++/HIP kernels to binary code objects. The file format for binary is <code>.co</code> which means Code Object. The following command builds the code object using <code>hipcc</code>.</sub></p>
<p ><sub><code>hipcc --genco --offload-arch=[TARGET GPU] [INPUT FILE] -o [OUTPUT FILE]</code></sub></p>
<p ><sub></p><div class="fragment"><div class="line">[TARGET GPU] = GPU architecture</div>
<div class="line">[INPUT FILE] = Name of the file containing kernels</div>
<div class="line">[OUTPUT FILE] = Name of the generated code object file</div>
</div><!-- fragment --><p></sub></p>
<p ><sub>Note: When using binary code objects is that the number of arguments to the kernel is different on HIP-Clang and NVCC path. Refer to the sample in samples/0_Intro/module_api for differences in the arguments to be passed to the kernel.</sub></p>
<p ><sub></sub></p>
<h1><a class="anchor" id="autotoc_md688"></a>
gfx-arch-specific-kernel</h1>
<p ><sub>Clang defined '<b>gfx*</b>' macros can be used to execute gfx arch specific codes inside the kernel. Refer to the sample 14_gpu_arch in samples/2_Cookbook. </sub></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
