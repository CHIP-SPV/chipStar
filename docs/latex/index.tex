\hypertarget{index_intro}{}\doxysection{Introduction}\label{index_intro}
For many large applications C++ is the language of choice and so it seems reasonable to define C++ bindings for Open\+CL.

The interface is contained with a single C++ header file {\itshape \mbox{\hyperlink{cl_8hpp}{cl.\+hpp}}} and all definitions are contained within the namespace {\itshape cl}. There is no additional requirement to include {\itshape \mbox{\hyperlink{cl_8h_source}{cl.\+h}}} and to use either the C++ or original C bindings it is enough to simply include {\itshape \mbox{\hyperlink{cl_8hpp}{cl.\+hpp}}}.

The bindings themselves are lightweight and correspond closely to the underlying C API. Using the C++ bindings introduces no additional execution overhead.

For detail documentation on the bindings see\+:

The Open\+CL C++ Wrapper API 1.\+2 (revision 09) \href{http://www.khronos.org/registry/cl/specs/opencl-cplusplus-1.2.pdf}{\texttt{ http\+://www.\+khronos.\+org/registry/cl/specs/opencl-\/cplusplus-\/1.\+2.\+pdf}}\hypertarget{index_example}{}\doxysection{Example}\label{index_example}
The following example shows a general use case for the C++ bindings, including support for the optional exception feature and also the supplied vector and string classes, see following sections for decriptions of these features.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define \_\_CL\_ENABLE\_EXCEPTIONS}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#if defined(\_\_APPLE\_\_) || defined(\_\_MACOSX)}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <OpenCL/cl.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#else}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <\mbox{\hyperlink{cl_8hpp}{CL/cl.hpp}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cstdlib>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{keyword}{const} \textcolor{keywordtype}{char} * helloStr  = \textcolor{stringliteral}{"{}\_\_kernel void "{}}}
\DoxyCodeLine{                          \textcolor{stringliteral}{"{}hello(void) "{}}}
\DoxyCodeLine{                          \textcolor{stringliteral}{"{}\{ "{}}}
\DoxyCodeLine{                          \textcolor{stringliteral}{"{}  "{}}}
\DoxyCodeLine{                          \textcolor{stringliteral}{"{}\} "{}};}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{keywordtype}{int}}
\DoxyCodeLine{ main(\textcolor{keywordtype}{void})}
\DoxyCodeLine{ \{}
\DoxyCodeLine{    cl\_int err = CL\_SUCCESS;}
\DoxyCodeLine{    \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{}
\DoxyCodeLine{      std::vector<cl::Platform> platforms;}
\DoxyCodeLine{      \mbox{\hyperlink{classcl_1_1_platform_af411de5b4cb0f553ea1dc2147e58d837}{cl::Platform::get}}(\&platforms);}
\DoxyCodeLine{      \textcolor{keywordflow}{if} (platforms.size() == 0) \{}
\DoxyCodeLine{          std::cout << \textcolor{stringliteral}{"{}Platform size 0\(\backslash\)n"{}};}
\DoxyCodeLine{          \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{      \}}
\DoxyCodeLine{}
\DoxyCodeLine{      cl\_context\_properties properties[] = }
\DoxyCodeLine{         \{ CL\_CONTEXT\_PLATFORM, (cl\_context\_properties)(platforms[0])(), 0\};}
\DoxyCodeLine{      \mbox{\hyperlink{classcl_1_1_context}{cl::Context}} context(CL\_DEVICE\_TYPE\_CPU, properties); }
\DoxyCodeLine{}
\DoxyCodeLine{      std::vector<cl::Device> devices = context.getInfo<CL\_CONTEXT\_DEVICES>();}
\DoxyCodeLine{}
\DoxyCodeLine{      cl::Program::Sources source(1,}
\DoxyCodeLine{          std::make\_pair(helloStr,strlen(helloStr)));}
\DoxyCodeLine{      \mbox{\hyperlink{classcl_1_1_program}{cl::Program}} program\_ = \mbox{\hyperlink{classcl_1_1_program}{cl::Program}}(context, source);}
\DoxyCodeLine{      program\_.build(devices);}
\DoxyCodeLine{}
\DoxyCodeLine{      \mbox{\hyperlink{classcl_1_1_kernel}{cl::Kernel}} kernel(program\_, \textcolor{stringliteral}{"{}hello"{}}, \&err);}
\DoxyCodeLine{}
\DoxyCodeLine{      \mbox{\hyperlink{classcl_1_1_event}{cl::Event}} event;}
\DoxyCodeLine{      \mbox{\hyperlink{classcl_1_1_command_queue}{cl::CommandQueue}} queue(context, devices[0], 0, \&err);}
\DoxyCodeLine{      queue.enqueueNDRangeKernel(}
\DoxyCodeLine{          kernel, }
\DoxyCodeLine{          cl::NullRange, }
\DoxyCodeLine{          \mbox{\hyperlink{classcl_1_1_n_d_range}{cl::NDRange}}(4,4),}
\DoxyCodeLine{          cl::NullRange,}
\DoxyCodeLine{          NULL,}
\DoxyCodeLine{          \&event); }
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{keyword}{event}.wait();}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keywordflow}{catch} (cl::Error err) \{}
\DoxyCodeLine{       std::cerr }
\DoxyCodeLine{          << \textcolor{stringliteral}{"{}ERROR: "{}}}
\DoxyCodeLine{          << err.what()}
\DoxyCodeLine{          << \textcolor{stringliteral}{"{}("{}}}
\DoxyCodeLine{          << err.err()}
\DoxyCodeLine{          << \textcolor{stringliteral}{"{})"{}}}
\DoxyCodeLine{          << std::endl;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{   \textcolor{keywordflow}{return} EXIT\_SUCCESS;}
\DoxyCodeLine{ \}}

\end{DoxyCode}
 