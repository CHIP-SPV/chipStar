// Copyright (c) 1993-2016, NVIDIA CORPORATION. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name of NVIDIA CORPORATION nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This code modified from the public domain code here:
// https://gist.github.com/rygorous/2156668
// The URL above includes more robust conversion routines
// that handle Inf and NaN correctly.
//
// It is recommended to use the more robust versions in production code.

typedef unsigned uint;

union FP32 {
  uint u;
  float f;
  struct {
    uint Mantissa : 23;
    uint Exponent : 8;
    uint Sign : 1;
  };
  struct {
    uint ExpMant : 31;
    uint Sign2 : 1;
  };
};

union FP16 {
  unsigned short u;
  struct {
    uint Mantissa : 10;
    uint Exponent : 5;
    uint Sign : 1;
  };
  struct {
    uint ExpMant : 15;
    uint Sign2 : 1;
  };
};

// Approximate solution. This is faster but converts some sNaNs to
// infinity and doesn't round correctly. Handle with care.
// Approximate solution. This is faster but converts some sNaNs to
// infinity and doesn't round correctly. Handle with care.
static const half approx_float_to_half(float fl) {
  FP32 f32infty = {255 << 23};
  FP32 f16max = {(127 + 16) << 23};
  FP32 magic = {15 << 23};
  FP32 expinf = {(255 ^ 31) << 23};
  uint sign_mask = 0x80000000u;
  FP16 o = {0};

  FP32 f = *((FP32 *)&fl);

  uint sign = f.u & sign_mask;
  f.u ^= sign;

  if (!(f.f < f32infty.u)) // Inf or NaN
    o.u = f.u ^ expinf.u;
  else {
    if (f.f > f16max.f)
      f.f = f16max.f;
    f.f *= magic.f;
  }

  o.u = f.u >> 13; // Take the mantissa bits
  o.u |= sign >> 16;
  return *((half *)&o);
}

// from half->float code - just for verification.
static float half_to_float(half hf) {
  __half temp = static_cast<__half>(hf);
  FP16 h;
  h.u = temp;

  static const FP32 magic = {113 << 23};
  static const uint shifted_exp = 0x7c00 << 13; // exponent mask after shift
  FP32 o;

  o.u = (h.u & 0x7fff) << 13;   // exponent/mantissa bits
  uint exp = shifted_exp & o.u; // just the exponent
  o.u += (127 - 15) << 23;      // exponent adjust

  // handle exponent special cases
  if (exp == shifted_exp)    // Inf/NaN?
    o.u += (128 - 16) << 23; // extra exp adjust
  else if (exp == 0)         // Zero/Denormal?
  {
    o.u += 1 << 23; // extra exp adjust
    o.f -= magic.f; // renormalize
  }

  o.u |= (h.u & 0x8000) << 16; // sign bit
  return o.f;
}

/* hopefully a more reasonable diff than testing by
 *    std::fabs(a - b) > eps
 * ...which compares absolute values to epsilon.
 */
static int compare_calculated(half h1, half h2) {
  FP16 h_1, h_2;
  __half temp = static_cast<__half>(h1);
  h_1.u = temp;
  temp = static_cast<__half>(h2);
  h_2.u = temp;

  // also deliberately compares equal infs and equal-value nans
  if (h_1.u == h_2.u)
    return 0;

  // compare nans equal if sign equals
  if (h_1.Exponent == 0x1f || h_2.Exponent == 0x1f) {
    return (h_1.Sign == h_2.Sign) ? 0 : INT32_MAX;
  }

  if (h_1.Sign != h_2.Sign)
    return INT32_MAX;

  // if sign & exponent are equal, this should return diff in ULP
  if (h_1.ExpMant > h_2.ExpMant)
    return h_1.ExpMant - h_2.ExpMant;
  else
    return h_2.ExpMant - h_1.ExpMant;
}
